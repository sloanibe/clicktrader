using System;
using System.Drawing;
using System.Collections.Generic;
using PowerLanguage.Function;
using System.Windows.Forms;

namespace PowerLanguage.Indicator
{
    [RecoverDrawings(false)]
    [SameAsSymbol(true)]
    [UpdateOnEveryTick(true)] // Update on every tick
    public class projected_future_range : IndicatorObject
    {
        [Input]
        public int TickOffset { get; set; }
        
        [Input]
        public bool AutoDetectOffset { get; set; }
        
        [Input]
        public Color BullishColor { get; set; }
        
        [Input]
        public Color BearishColor { get; set; }
        
        // LineWidth removed as it's not supported by MultiCharts .NET trend lines
        
        [Input]
        public int LineLength { get; set; }

        private IPlotObject m_Plot;
        private ITrendLineObject m_BullishLine;
        private ITrendLineObject m_BearishLine;
        private double m_LastLow;
        private double m_LastHigh;
        private DateTime m_LastBarTime;
        private bool m_NeedToUpdate;

        public projected_future_range(object ctx) : base(ctx)
        {
            TickOffset = 8; // Default to 8 ticks (will be overridden by auto-detection)
            AutoDetectOffset = true; // ALWAYS enable auto-detection by default
            BullishColor = Color.Green; // Default to green for bullish
            BearishColor = Color.Red; // Default to red for bearish
            LineLength = 30; // Default line length in bars - increased for better visibility
        }

        protected override void Create()
        {
            // Create an invisible plot that doesn't affect the chart
            m_Plot = AddPlot(new PlotAttributes("Projection", EPlotShapes.Line, Color.Transparent));
            m_NeedToUpdate = false;
        }

        // Method to detect the bar range and calculate an appropriate tick offset
        private int DetectBarRangeOffset()
        {
            try
            {
                // IMPORTANT: Make sure we have at least 2 bars to access the previous completed bar
                if (Bars.CurrentBar < 2)
                    return TickOffset; // Return the default value
                
                // For range bars, every bar has the same size by definition
                // Use the previous COMPLETED bar (index 1), not the current developing bar
                double barRange = Bars.High[1] - Bars.Low[1];
                
                // Safety check - if the range is zero or negative, use the default
                if (barRange <= 0)
                    return TickOffset;
                
                // Calculate the tick size
                double tickSize = Bars.Info.MinMove / Bars.Info.PriceScale;
                
                // Convert the bar range to ticks
                double rangeInTicks = barRange / tickSize;
                
                // Use the FULL range as the offset (not a percentage)
                // Make sure we're getting the exact number of ticks in the range bar
                int calculatedOffset = (int)Math.Round(rangeInTicks);
                
                // Ensure the offset is at least 2 ticks
                calculatedOffset = Math.Max(2, calculatedOffset);
                
                // Debug info - enable console logging
                Output.WriteLine("Range bar size detected: " + calculatedOffset + " ticks (from current bar)");
                
                return calculatedOffset;
            }
            catch (Exception ex)
            {
                // Silently handle errors
                return TickOffset; // Return the default value on error
            }
        }
        
        protected override void StartCalc()
        {
            ClearLines();
            
            // Initialize with the most recent bar data - ensure we have at least 2 bars
            // We need 2 bars to access the previous completed bar
            if (Bars.CurrentBar > 1)
            {
                try
                {
                    Output.WriteLine("StartCalc: Initializing with previous completed bar data");
                    
                    // If auto-detection is enabled, calculate the appropriate tick offset
                    // from the previous completed bar
                    if (AutoDetectOffset)
                    {
                        int calculatedOffset = DetectBarRangeOffset();
                        TickOffset = calculatedOffset; // Always use the detected offset
                        Output.WriteLine("StartCalc: Set TickOffset to " + TickOffset + " ticks based on previous completed bar");
                    }
                    
                    // Get the current bar data for projections
                    // We still use the current bar for the actual projections
                    m_LastLow = Bars.Low[0];
                    m_LastHigh = Bars.High[0];
                    m_LastBarTime = Bars.Time[0];
                    
                    Output.WriteLine("StartCalc: Current bar for projections - Low: " + m_LastLow + ", High: " + m_LastHigh);
                    
                    // Draw projections immediately
                    DrawProjections();
                }
                catch (Exception ex)
                {
                    Output.WriteLine("ERROR in StartCalc: " + ex.Message);
                }
            }
            else
            {
                // Not enough bars yet
                m_LastLow = 0;
                m_LastHigh = 0;
                Output.WriteLine("StartCalc: Not enough bars available yet");
            }
        }

        // Track the current bar index to detect new bars
        private int m_LastBarIndex = -1;
        
        protected override void CalcBar()
        {
            try
            {
                // Keep indicator active with a constant value that won't affect the chart
                m_Plot.Set(0);
                
                // Check if this is a new bar
                bool isNewBar = (Bars.CurrentBar != m_LastBarIndex);
                
                // Make sure we have access to the current bar's data
                if (Bars.CurrentBar >= 0)
                {
                    // Always update with the current developing bar's data
                    // For the current developing bar, we need to use Bars.Close[0] for the latest price
                    m_LastLow = Bars.Status == EBarState.Close ? Bars.Low[0] : Math.Min(Bars.Low[0], Bars.Close[0]);
                    m_LastHigh = Bars.Status == EBarState.Close ? Bars.High[0] : Math.Max(Bars.High[0], Bars.Close[0]);
                    m_LastBarTime = Bars.Time[0];
                    m_LastBarIndex = Bars.CurrentBar;
                    
                    // Only update the tick offset if we have at least 2 bars
                    // This ensures we're using the previous completed bar for detection
                    if (Bars.CurrentBar > 1)
                    {
                        TickOffset = DetectBarRangeOffset(); // Always use the detected offset from previous bar
                        Output.WriteLine("CalcBar: Updated TickOffset to " + TickOffset + " ticks from previous completed bar");
                    }
                    
                    // If this is a new bar, clear old projections first
                    if (isNewBar)
                    {
                        ClearLines();
                        Output.WriteLine("CalcBar: New bar detected - cleared old projections");
                    }
                    
                    // Always draw the projections to update in real-time as the bar develops
                    DrawProjections();
                }
                else
                {
                    Output.WriteLine("CalcBar: Not enough bar data available");
                }
            }
            catch (Exception ex)
            {
                Output.WriteLine("ERROR in CalcBar: " + ex.Message);
            }
        }

        private void DrawProjections()
        {
            try
            {
                // Clear previous lines
                ClearLines();
                
                // Calculate the tick size
                double tickSize = Bars.Info.MinMove / Bars.Info.PriceScale;
                
                // Get the exact range from the last completed bar
                int rangeInTicks;
                
                // IMPORTANT: Check if we have access to the previous completed bar
                if (Bars.CurrentBar > 1)
                {
                    try
                    {
                        // Calculate the range directly from the previous COMPLETED bar
                        double barRange = Bars.High[1] - Bars.Low[1];
                        
                        // Safety check - if the range is zero or negative, use the default
                        if (barRange <= 0)
                        {
                            rangeInTicks = TickOffset;
                            Output.WriteLine("DrawProjections: Invalid bar range detected, using default TickOffset = " + TickOffset);
                        }
                        else
                        {
                            rangeInTicks = (int)Math.Round(barRange / tickSize);
                            rangeInTicks = Math.Max(2, rangeInTicks); // Ensure at least 2 ticks
                            
                            // Log the range bar size and tick size
                            Output.WriteLine("DrawProjections: Using previous completed bar - Range = " + barRange + " points (" + rangeInTicks + " ticks)");
                            Output.WriteLine("DrawProjections: Tick size = " + tickSize);
                        }
                    }
                    catch
                    {
                        // If any error occurs, fall back to default
                        rangeInTicks = TickOffset;
                        Output.WriteLine("DrawProjections: Error accessing bar data, using default TickOffset = " + TickOffset);
                    }
                }
                else
                {
                    // Fall back to TickOffset if we don't have enough bars
                    rangeInTicks = TickOffset;
                    Output.WriteLine("DrawProjections: Not enough bars available, using default TickOffset = " + TickOffset);
                }
                
                // Calculate projection prices using the exact range bar size
                double bullishProjection = m_LastLow + (rangeInTicks * tickSize);
                double bearishProjection = m_LastHigh - (rangeInTicks * tickSize);
                
                // Log the projection prices and current bar data
                Output.WriteLine("DrawProjections: Current bar - Low: " + m_LastLow + ", High: " + m_LastHigh);
                Output.WriteLine("DrawProjections: Projections - Bullish: " + bullishProjection + ", Bearish: " + bearishProjection);
                
                // Calculate start and end points for the trend lines
                // Start at the current bar
                DateTime startTime = Bars.Time[0];
                
                // Make the lines extend based on the LineLength parameter
                // This makes them more visible on the chart
                DateTime endTime = startTime.AddSeconds(LineLength);
                
                try
                {
                    // Draw bullish projection (horizontal line above the low)
                    ChartPoint bullishStart = new ChartPoint(startTime, bullishProjection);
                    ChartPoint bullishEnd = new ChartPoint(endTime, bullishProjection);
                    
                    Output.WriteLine("Creating bullish line from " + startTime + " to " + endTime + " at price " + bullishProjection);
                    m_BullishLine = DrwTrendLine.Create(bullishStart, bullishEnd);
                    m_BullishLine.Color = BullishColor;
                    
                    // Draw bearish projection (horizontal line below the high)
                    ChartPoint bearishStart = new ChartPoint(startTime, bearishProjection);
                    ChartPoint bearishEnd = new ChartPoint(endTime, bearishProjection);
                    
                    Output.WriteLine("Creating bearish line from " + startTime + " to " + endTime + " at price " + bearishProjection);
                    m_BearishLine = DrwTrendLine.Create(bearishStart, bearishEnd);
                    m_BearishLine.Color = BearishColor;
                    
                    Output.WriteLine("Lines created successfully");
                }
                catch (Exception ex)
                {
                    // Log any errors that occur during drawing
                    Output.WriteLine("ERROR creating projection lines: " + ex.Message);
                }
            }
            catch (Exception ex)
            {
                // Log any errors in the outer try-catch block
                Output.WriteLine("ERROR in DrawProjections method: " + ex.Message);
                Output.WriteLine("Stack trace: " + ex.StackTrace);
            }
        }

        private void ClearLines()
        {
            try
            {
                if (m_BullishLine != null)
                {
                    m_BullishLine.Delete();
                    m_BullishLine = null;
                }
                
                if (m_BearishLine != null)
                {
                    m_BearishLine.Delete();
                    m_BearishLine = null;
                }
            }
            catch
            {
                // Ignore errors during cleanup
            }
        }
    }
}
