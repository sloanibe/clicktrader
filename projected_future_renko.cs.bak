using System;
using System.Drawing;
using System.Collections.Generic;
using PowerLanguage.Function;
using System.Windows.Forms;

namespace PowerLanguage.Indicator
{
    [RecoverDrawings(false)]
    [SameAsSymbol(true)]
    public class projected_future_renko : IndicatorObject
    {
        [Input]
        public int BarWidthPixels { get; set; }

        [Input]
        public Color SameDirectionColor { get; set; }

        [Input]
        public Color OppositeDirectionColor { get; set; }

        [Input]
        public bool ShowOppositeProjection { get; set; }

        private IPlotObject m_Plot;
        private List<ITrendLineObject> m_SameDirectionLines;
        private List<ITrendLineObject> m_OppositeDirectionLines;
        private bool m_NeedToUpdate;
        private double m_LastClosePrice;
        private double m_SameDirectionPrice;
        private double m_OppositeDirectionPrice;
        private DateTime m_LastCloseTime;
        private bool m_LastBarWasUp;
        private double m_BoxSize;

        public projected_future_renko(object ctx) : base(ctx)
        {
            BarWidthPixels = 3; // Default to 3 pixels width (narrower)
            SameDirectionColor = Color.Blue; // Default to blue for up bars
            OppositeDirectionColor = Color.Red; // Default to red for down bars
            ShowOppositeProjection = true; // Enable opposite direction projection by default
        }

        protected override void Create()
        {
            // Create an invisible plot that doesn't affect the chart
            m_Plot = AddPlot(new PlotAttributes("Projection", EPlotShapes.Line, Color.Transparent));
            m_SameDirectionLines = new List<ITrendLineObject>();
            m_OppositeDirectionLines = new List<ITrendLineObject>();
            m_NeedToUpdate = false;
        }

        protected override void StartCalc()
        {
            ClearAllLines();
            
            // Initialize with the most recent bar data so we don't have to wait for a new bar
            if (Bars.CurrentBar > 1) // Check if we have at least 2 bars
            {
                // Get the last COMPLETED bar (index 1) and the one before it
                double lastBarClose = Bars.Close[1]; // Last completed bar
                double previousBarClose = Bars.Close[2]; // Bar before the last completed bar
                
                // Determine bar direction (up or down) based on the last completed bar
                bool isUpBar = lastBarClose > previousBarClose;
                
                // Detect if this is a color change bar (direction changed from previous bar)
                m_IsColorChangeBar = false;
                if (Bars.CurrentBar > 2) // Need at least 3 bars to detect color change
                {
                    double twoBarsPriorClose = Bars.Close[3]; // Three bars ago
                    bool priorBarWasUp = previousBarClose > twoBarsPriorClose;
                    m_IsColorChangeBar = (isUpBar != priorBarWasUp);
                }
                
                // Calculate the box size from the last completed bar
                m_BoxSize = Math.Abs(lastBarClose - previousBarClose);
                
                // Store the values from the last completed bar
                m_LastClosePrice = lastBarClose;
                m_LastCloseTime = Bars.Time[1]; // Time of the last completed bar
                m_LastBarWasUp = isUpBar;
                
                // Calculate projection prices
                if (isUpBar)
                {
                    // For up bars, project one box size up from close
                    m_SameDirectionPrice = lastBarClose + m_BoxSize;
                    // For opposite direction, project one box size down from close
                    m_OppositeDirectionPrice = lastBarClose - m_BoxSize;
                }
                else
                {
                    // For down bars, project one box size down from close
                    m_SameDirectionPrice = lastBarClose - m_BoxSize;
                    // For opposite direction, project one box size up from close
                    m_OppositeDirectionPrice = lastBarClose + m_BoxSize;
                }
                
                // Draw projections immediately
                DrawSameDirectionProjection(m_IsColorChangeBar);
                
                if (ShowOppositeProjection)
                {
                    DrawOppositeDirectionProjection(m_IsColorChangeBar);
                }
                
                // No need to set flag since we already drew the projections
                m_NeedToUpdate = false;
            }
            else
            {
                // Not enough bars yet
                m_NeedToUpdate = false;
                m_LastClosePrice = 0;
                m_SameDirectionPrice = 0;
                m_OppositeDirectionPrice = 0;
                m_BoxSize = 0;
                m_LastBarWasUp = false;
            }
        }

        // Class-level variable to track color change
        private bool m_IsColorChangeBar = false;
        
        protected override void CalcBar()
        {
            // Keep indicator active with a constant value that won't affect the chart
            m_Plot.Set(0);

            // Process immediately on every tick to ensure projections are always visible
            // But only update when we have a new bar or on the first calculation
            bool isNewBar = false;

            // Make sure we have at least 2 bars (current and last completed)
            if (Bars.CurrentBar > 1)
            {
                // Get the last COMPLETED bar (index 1)
                double lastBarClose = Bars.Close[1];
                
                // Check if this is a new bar or the first calculation
                if (m_LastClosePrice == 0 || lastBarClose != m_LastClosePrice)
                {
                    isNewBar = true;
                    
                    // Get the bar before the last completed bar
                    double previousBarClose = (Bars.CurrentBar > 2) ? Bars.Close[2] : Bars.Open[1];

                    // Determine bar direction (up or down) based on the last completed bar
                    bool isUpBar = lastBarClose > previousBarClose;
                
                    // Detect if this is a color change bar
                    m_IsColorChangeBar = false;
                    if (Bars.CurrentBar > 2) // Need at least 3 bars to detect color change
                    {
                        double twoBarsPriorClose = Bars.Close[3]; // Three bars ago
                        bool priorBarWasUp = previousBarClose > twoBarsPriorClose;
                        m_IsColorChangeBar = (isUpBar != priorBarWasUp);
                    }
                
                    // Bar direction and color change detected

                    // Calculate the Renko box size based on the last completed bar
                    m_BoxSize = Math.Abs(lastBarClose - previousBarClose);

                    // Store the values from the last completed bar
                    m_LastClosePrice = lastBarClose;
                    m_LastCloseTime = Bars.Time[1]; // Time of the last completed bar
                    m_LastBarWasUp = isUpBar;

                    // Project the next bar in the same direction
                    if (isUpBar)
                    {
                        // For up bars, project one box size up from close
                        m_SameDirectionPrice = lastBarClose + m_BoxSize;
                        // For opposite direction, project one box size down from close
                        m_OppositeDirectionPrice = lastBarClose - m_BoxSize;
                    }
                    else
                    {
                        // For down bars, project one box size down from close
                        m_SameDirectionPrice = lastBarClose - m_BoxSize;
                        // For opposite direction, project one box size up from close
                        m_OppositeDirectionPrice = lastBarClose + m_BoxSize;
                    }

                    // Clear previous projections
                    ClearAllLines();
                    
                    // Draw projections immediately
                    DrawSameDirectionProjection(m_IsColorChangeBar);

                    if (ShowOppositeProjection)
                    {
                        DrawOppositeDirectionProjection(m_IsColorChangeBar);
                    }
                    
                    // No need to update again until a new bar
                    m_NeedToUpdate = false;
                }
            }
        }

        private void DrawSameDirectionProjection(bool isColorChangeBar = false)
        {
            try
            {
                // Calculate the Renko box coordinates
                DateTime leftTime = m_LastCloseTime;

                // Use a small time increment for width
                DateTime rightTime = leftTime.AddMilliseconds(BarWidthPixels * 10); // Scale factor of 10ms per pixel

                // Determine the bottom and top prices based on direction
                double bottomPrice, topPrice;
                
                // For Renko bars, we need to ensure the projection is exactly one box size
                // For color change bars, we need special handling
                if (m_LastBarWasUp)
                {
                    if (isColorChangeBar)
                    {
                        // For color change up bars, we need to use half the box size
                        bottomPrice = m_LastClosePrice;
                        topPrice = bottomPrice + (m_BoxSize / 2); // Half box size for color change bars
                    }
                    else
                    {
                        // For regular up bars, bottom is last close, top is exactly one box size higher
                        bottomPrice = m_LastClosePrice;
                        topPrice = bottomPrice + m_BoxSize; // Exactly one box size
                    }
                }
                else
                {
                    if (isColorChangeBar)
                    {
                        // For color change down bars, we need to use half the box size
                        topPrice = m_LastClosePrice;
                        bottomPrice = topPrice - (m_BoxSize / 2); // Half box size for color change bars
                    }
                    else
                    {
                        // For regular down bars, top is last close, bottom is exactly one box size lower
                        topPrice = m_LastClosePrice;
                        bottomPrice = topPrice - m_BoxSize; // Exactly one box size
                    }
                }

                try
                {
                    // Create points for the rectangle
                    ChartPoint bottomLeft = new ChartPoint(leftTime, bottomPrice);
                    ChartPoint bottomRight = new ChartPoint(rightTime, bottomPrice);
                    ChartPoint topLeft = new ChartPoint(leftTime, topPrice);
                    ChartPoint topRight = new ChartPoint(rightTime, topPrice);

                    // Use blue for up bars and red for down bars
                    Color lineColor = m_LastBarWasUp ? Color.Blue : Color.Red;
                    
                    // Draw bottom line
                    ITrendLineObject bottomLine = DrwTrendLine.Create(bottomLeft, bottomRight);
                    bottomLine.Color = lineColor;
                    m_SameDirectionLines.Add(bottomLine);

                    // Draw top line
                    ITrendLineObject topLine = DrwTrendLine.Create(topLeft, topRight);
                    topLine.Color = lineColor;
                    m_SameDirectionLines.Add(topLine);

                    // Draw left line
                    ITrendLineObject leftLine = DrwTrendLine.Create(bottomLeft, topLeft);
                    leftLine.Color = lineColor;
                    m_SameDirectionLines.Add(leftLine);

                    // Draw right line
                    ITrendLineObject rightLine = DrwTrendLine.Create(bottomRight, topRight);
                    rightLine.Color = lineColor;
                    m_SameDirectionLines.Add(rightLine);

                    // Same direction projection complete
                }
                catch (Exception ex)
                {
                    // Silently handle errors
                }
            }
            catch (Exception ex)
            {
                // Silently handle errors
            }
        }

        private void DrawOppositeDirectionProjection(bool isColorChangeBar = false)
        {
            try
            {
                // Calculate the Renko box coordinates
                DateTime leftTime = m_LastCloseTime;

                // Use a small time increment for width
                DateTime rightTime = leftTime.AddMilliseconds(BarWidthPixels * 10); // Scale factor of 10ms per pixel

                // For opposite direction projection, we need to start at the open of the next potential bar
                double bottomPrice, topPrice;

                // For opposite direction projection, we need special handling for color change bars
                if (m_LastBarWasUp)
                {
                    if (isColorChangeBar)
                    {
                        // For color change up bars, the opposite projection should start at the close
                        // and project one box size down
                        topPrice = m_LastClosePrice;
                        bottomPrice = topPrice - m_BoxSize; // Exactly one box size
                        // Color change UP bar - opposite direction projection
                    }
                    else
                    {
                        // For regular up bars, start at the open and project down
                        // For an up bar, the open is at the bottom
                        double openPrice = m_LastClosePrice - m_BoxSize;
                        
                        // Project one box size down from the open
                        topPrice = openPrice;
                        bottomPrice = openPrice - m_BoxSize; // Exactly one box size
                    }
                }
                else
                {
                    if (isColorChangeBar)
                    {
                        // For color change down bars, the opposite projection should start at the close
                        // and project one box size up
                        bottomPrice = m_LastClosePrice;
                        topPrice = bottomPrice + m_BoxSize; // Exactly one box size
                        // Color change DOWN bar - opposite direction projection
                    }
                    else
                    {
                        // For regular down bars, start at the open and project up
                        // For a down bar, the open is at the top
                        double openPrice = m_LastClosePrice + m_BoxSize;
                        
                        // Project one box size up from the open
                        bottomPrice = openPrice;
                        topPrice = openPrice + m_BoxSize; // Exactly one box size
                    }
                }

                try
                {
                    // Create points for the rectangle
                    ChartPoint bottomLeft = new ChartPoint(leftTime, bottomPrice);
                    ChartPoint bottomRight = new ChartPoint(rightTime, bottomPrice);
                    ChartPoint topLeft = new ChartPoint(leftTime, topPrice);
                    ChartPoint topRight = new ChartPoint(rightTime, topPrice);

                    // For opposite direction, use red for up bars (projecting down) and blue for down bars (projecting up)
                    // This is the reverse of the same direction projection
                    Color lineColor = m_LastBarWasUp ? Color.Red : Color.Blue;
                    
                    // Draw bottom line
                    ITrendLineObject bottomLine = DrwTrendLine.Create(bottomLeft, bottomRight);
                    bottomLine.Color = lineColor;
                    m_OppositeDirectionLines.Add(bottomLine);

                    // Draw top line
                    ITrendLineObject topLine = DrwTrendLine.Create(topLeft, topRight);
                    topLine.Color = lineColor;
                    m_OppositeDirectionLines.Add(topLine);

                    // Draw left line
                    ITrendLineObject leftLine = DrwTrendLine.Create(bottomLeft, topLeft);
                    leftLine.Color = lineColor;
                    m_OppositeDirectionLines.Add(leftLine);

                    // Draw right line
                    ITrendLineObject rightLine = DrwTrendLine.Create(bottomRight, topRight);
                    rightLine.Color = lineColor;
                    m_OppositeDirectionLines.Add(rightLine);

                    // Opposite direction projection complete
                }
                catch (Exception ex)
                {
                    // Silently handle errors
                }
            }
            catch (Exception ex)
            {
                // Silently handle errors
            }
        }

        // Helper method to clear all lines
        private void ClearAllLines()
        {
            ClearSameDirectionLines();
            ClearOppositeDirectionLines();
        }

        // Helper method to clear same direction lines
        private void ClearSameDirectionLines()
        {
            if (m_SameDirectionLines != null)
            {
                foreach (var line in m_SameDirectionLines)
                {
                    try
                    {
                        line.Delete();
                    }
                    catch
                    {
                        // Ignore errors during cleanup
                    }
                }

                m_SameDirectionLines.Clear();
            }
        }

        // Helper method to clear opposite direction lines
        private void ClearOppositeDirectionLines()
        {
            if (m_OppositeDirectionLines != null)
            {
                foreach (var line in m_OppositeDirectionLines)
                {
                    try
                    {
                        line.Delete();
                    }
                    catch
                    {
                        // Ignore errors during cleanup
                    }
                }

                m_OppositeDirectionLines.Clear();
            }
        }
    }
}
